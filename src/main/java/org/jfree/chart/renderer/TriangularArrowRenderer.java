/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2013, by Object Refinery Limited and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
 * Other names may be trademarks of their respective owners.]
 *
 * -------------------
 * VectorRenderer.java
 * -------------------
 * (C) Copyright 2007-2013, by Object Refinery Limited.
 *
 * Original Author:  David Gilbert (for Object Refinery Limited);
 * Contributor(s):   -;
 *
 * Changes
 * -------
 * 30-Jan-2007 : Version 1 (DG);
 * 24-May-2007 : Updated for method name changes (DG);
 * 25-May-2007 : Moved from experimental to the main source tree (DG);
 * 18-Feb-2008 : Fixed bug 1880114, arrows for horizontal plot
 *               orientation (DG);
 * 22-Apr-2008 : Implemented PublicCloneable (DG);
 * 26-Sep-2008 : Added chart entity support (tooltips etc) (DG);
 * 03-Jul-2013 : Use ParamChecks (DG);
 *
 */

package org.jfree.chart.renderer;

import java.awt.Graphics2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;

import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.VectorRenderer;
import org.jfree.chart.renderer.xy.XYItemRendererState;
import org.jfree.data.xy.VectorXYDataset;
import org.jfree.data.xy.XYDataset;

/**
 * A renderer that represents data from an {@link VectorXYDataset} by drawing a
 * line with an arrow at each (x, y) point.
 * The example shown here is generated by the <code>VectorPlotDemo1.java</code>
 * program included in the JFreeChart demo collection:
 * <br><br>
 * <img src="../../../../../images/VectorRendererSample.png"
 * alt="VectorRendererSample.png" />
 *
 * @since 1.0.6
 */
public class TriangularArrowRenderer extends VectorRenderer {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	/** The length of the base. */
	private double baseLength = 0.10;

	/** The length of the head. */
	private double headLength = 0.20;

	/** The width of the head. */
	private double headWidth = 3;

	/**
	 * Creates a new <code>XYBlockRenderer</code> instance with default
	 * attributes.
	 */
	public TriangularArrowRenderer() {
	}


	/**
	 * Draws the block representing the specified item.
	 *
	 * @param g2  the graphics device.
	 * @param state  the state.
	 * @param dataArea  the data area.
	 * @param info  the plot rendering info.
	 * @param plot  the plot.
	 * @param domainAxis  the x-axis.
	 * @param rangeAxis  the y-axis.
	 * @param dataset  the dataset.
	 * @param series  the series index.
	 * @param item  the item index.
	 * @param crosshairState  the crosshair state.
	 * @param pass  the pass index.
	 */
	@Override
	public void drawItem(Graphics2D g2, XYItemRendererState state,
			Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot,
			ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset,
			int series, int item, CrosshairState crosshairState, int pass) {
		
		double x = dataset.getXValue(series, item);
		double y = dataset.getYValue(series, item);
		if (Double.isNaN(y) || Double.isNaN(x)) {
			return;
		}

		double topY = dataArea.getMaxY() - dataArea.getWidth() / 2.0 * Math.tan(Math.PI / 180.0 * 60.0);
		double endY = dataArea.getMaxY();

		double z = 1.0 - x - y;
		double offset = 0.5 * z * dataArea.getWidth();
		double transX =  dataArea.getX() + x*dataArea.getWidth()  + offset;
		double transY = topY + (1-z) * (endY-topY);
		
		
		double transX1 = 0;
		double transY1 = 0;
		if (dataset instanceof VectorXYDataset) {
			
			double dx = ((VectorXYDataset) dataset).getVectorXValue(series, item);
			double dy = ((VectorXYDataset) dataset).getVectorYValue(series, item);
			if (Double.isNaN(dx) || Double.isNaN(dy)) {
				return;
			}
			double a[] = normalize1(new double []{dx, dy});
			dx = a[0];
			dy = a[1];

			dx *= this.headLength;
			dy *= this.headLength;
			double x1 = x + dx;
			double y1 = y + dy;
			double z1 = 1.0 - x1 - y1;
			double offset1 = 0.5 * z1 * dataArea.getWidth();
			transX1 =  dataArea.getX() + x1*dataArea.getWidth()  + offset1;
			transY1 = topY + (1-z1) * (endY-topY);
			
		}
		
		double xx0 = transX;
		double yy0 = transY;
		double xx1 = transX1;
		double yy1 = transY1;

		Line2D line;
		PlotOrientation orientation = plot.getOrientation();
		if (orientation.equals(PlotOrientation.HORIZONTAL)) {
			line = new Line2D.Double(yy0, xx0, yy0, xx0);
		}
		else {
			line = new Line2D.Double(xx0, yy0, xx0, yy0);
		}
		g2.setPaint(getItemPaint(series, item));
		g2.setStroke(getItemStroke(series, item));
		g2.draw(line);

		// calculate the arrow head and draw it...
		double dxx = (xx1 - xx0);
		double dyy = (yy1 - yy0);

		double bx = xx0 + (1.0 - this.baseLength) * dxx;
		double by = yy0 + (1.0 - this.baseLength) * dyy;

		double cx = xx0 + (1.0 - this.headLength) * dxx;
		double cy = yy0 + (1.0 - this.headLength) * dyy;

		double angle = 0.0;
		if (dxx != 0.0) {
			angle = Math.PI / 2.0 - Math.atan(dyy / dxx);
		}

		double deltaX = headWidth*2 * Math.cos(angle);
		double deltaY = headWidth*2 * Math.sin(angle);

		double leftx = cx + deltaX;
		double lefty = cy - deltaY;
		double rightx = cx - deltaX;
		double righty = cy + deltaY;

		GeneralPath p = new GeneralPath();
		if (orientation == PlotOrientation.VERTICAL) {
			
			p.moveTo((float) xx0, (float) yy0);
			p.lineTo((float) rightx-dxx, (float) righty-dyy);
			p.lineTo((float) bx-dxx, (float) by-dyy);
			p.lineTo((float) leftx-dxx, (float) lefty-dyy);
			
		}
		else {  // orientation is HORIZONTAL
			p.moveTo((float) yy0, (float) xx0);
			p.lineTo((float) righty-dyy, (float) rightx-dxx);
			p.lineTo((float) by-dyy, (float) bx-dxx);
			p.lineTo((float) lefty-dyy, (float) leftx-dxx);
		}
		p.closePath();
		g2.draw(p);
		g2.fill(p);


		// setup for collecting optional entity info...
		EntityCollection entities;
		if (info != null) {
			entities = info.getOwner().getEntityCollection();
			if (entities != null) {
				addEntity(entities, line.getBounds(), dataset, series, item,
						0.0, 0.0);
			}
		}
	}

	public void setHeadWidth(double headWidth){
		this.headWidth = headWidth;
	}

	public double getHeadWidth(){
		return headWidth;
	}


	public void setHeadLength(double headLength){
		this.headLength = headLength;
	}

	public double getHeadLength(){
		return headLength;
	}

	double [] normalize1(double []x){
		double xsum = 0;
		for (int i = 0; i < x.length; i++)
			xsum += Math.abs(x[i]);
		for (int i = 0; i < x.length; i++)
			x[i] /= xsum;
		return x;
	}
	void normalize (double []x){
		double xsum = 0;
		for (int i = 0; i < x.length; i++)
			xsum += Math.abs(x[i]);
		for (int i = 0; i < x.length; i++)
			x[i] /= xsum;
	}

	void normalize(double x, double y){
		double sum = 0;
		sum += Math.abs(x);
		sum += Math.abs(y);
		x /= sum;
		y /= sum;
	}
}
