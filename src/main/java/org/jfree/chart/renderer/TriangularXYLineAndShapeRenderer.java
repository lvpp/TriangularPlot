/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2013, by Object Refinery Limited and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Oracle and Java are registered trademarks of Oracle and/or its affiliates.
 * Other names may be trademarks of their respective owners.]
 *
 * ---------------------------
 * XYLineAndShapeRenderer.java
 * ---------------------------
 * (C) Copyright 2004-2013, by Object Refinery Limited.
 *
 * Original Author:  David Gilbert (for Object Refinery Limited);
 * Contributor(s):   -;
 *
 * Changes:
 * --------
 * 27-Jan-2004 : Version 1 (DG);
 * 10-Feb-2004 : Minor change to drawItem() method to make cut-and-paste
 *               overriding easier (DG);
 * 25-Feb-2004 : Replaced CrosshairInfo with CrosshairState (DG);
 * 25-Aug-2004 : Added support for chart entities (required for tooltips) (DG);
 * 24-Sep-2004 : Added flag to allow whole series to be drawn as a path
 *               (necessary when using a dashed stroke with many data
 *               items) (DG);
 * 04-Oct-2004 : Renamed BooleanUtils --> BooleanUtilities (DG);
 * 11-Nov-2004 : Now uses ShapeUtilities to translate shapes (DG);
 * 27-Jan-2005 : The getLegendItem() method now omits hidden series (DG);
 * 28-Jan-2005 : Added new constructor (DG);
 * 09-Mar-2005 : Added fillPaint settings (DG);
 * 20-Apr-2005 : Use generators for legend tooltips and URLs (DG);
 * 22-Jul-2005 : Renamed defaultLinesVisible --> baseLinesVisible,
 *               defaultShapesVisible --> baseShapesVisible and
 *               defaultShapesFilled --> baseShapesFilled (DG);
 * 29-Jul-2005 : Added code to draw item labels (DG);
 * ------------- JFREECHART 1.0.x ---------------------------------------------
 * 20-Jul-2006 : Set dataset and series indices in LegendItem (DG);
 * 06-Feb-2007 : Fixed bug 1086307, crosshairs with multiple axes (DG);
 * 21-Feb-2007 : Fixed bugs in clone() and equals() (DG);
 * 20-Apr-2007 : Updated getLegendItem() for renderer change (DG);
 * 18-May-2007 : Set dataset and seriesKey for LegendItem (DG);
 * 08-Jun-2007 : Fix for bug 1731912 where entities are created even for data
 *               items that are not displayed (DG);
 * 26-Oct-2007 : Deprecated override attributes (DG);
 * 02-Jun-2008 : Fixed tooltips at lower edges of data area (DG);
 * 17-Jun-2008 : Apply legend shape, font and paint attributes (DG);
 * 19-Sep-2008 : Fixed bug with drawSeriesLineAsPath - patch by Greg Darke (DG);
 * 18-May-2009 : Clip lines in drawPrimaryLine() (DG);
 * 05-Jul-2012 : Removed JDK 1.3.1 code (DG);
 * 02-Jul-2013 : Use ParamChecks (DG);
 *
 */

package org.jfree.chart.renderer;

import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRendererState;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.chart.util.LineUtilities;
import org.jfree.data.xy.XYDataset;
import org.jfree.io.SerialUtilities;
import org.jfree.util.BooleanList;
import org.jfree.util.ShapeUtilities;

/**
 * A renderer that connects data points with lines and/or draws shapes at each
 * data point.  This renderer is designed for use with the {@link XYPlot}
 * class.  The example shown here is generated by
 * the <code>XYLineAndShapeRendererDemo2.java</code> program included in the
 * JFreeChart demo collection:
 * <br><br>
 * <img src="../../../../../images/XYLineAndShapeRendererSample.png"
 * alt="XYLineAndShapeRendererSample.png" />
 *
 */
public class TriangularXYLineAndShapeRenderer extends XYLineAndShapeRenderer {

	/** For serialization. */
	private static final long serialVersionUID = -7435246895986425885L;

	/**
	 * A flag that controls whether or not lines are visible for ALL series.
	 *
	 * @deprecated As of 1.0.7.
	 */
	@SuppressWarnings("unused")
	private Boolean linesVisible;

	/**
	 * A table of flags that control (per series) whether or not lines are
	 * visible.
	 */
	@SuppressWarnings("unused")
	private BooleanList seriesLinesVisible;

	/** The default value returned by the getLinesVisible() method. */
	@SuppressWarnings("unused")
	private boolean baseLinesVisible;

	/** The shape that is used to represent a line in the legend. */
	private transient Shape legendLine;

	/**
	 * A flag that controls whether or not shapes are visible for ALL series.
	 *
	 * @deprecated As of 1.0.7.
	 */
	@SuppressWarnings("unused")
	private Boolean shapesVisible;

	/**
	 * A table of flags that control (per series) whether or not shapes are
	 * visible.
	 */
	@SuppressWarnings("unused")
	private BooleanList seriesShapesVisible;

	/** The default value returned by the getShapeVisible() method. */
	@SuppressWarnings("unused")
	private boolean baseShapesVisible;

	/**
	 * A flag that controls whether or not shapes are filled for ALL series.
	 *
	 * @deprecated As of 1.0.7.
	 */
	@SuppressWarnings("unused")
	private Boolean shapesFilled;

	/**
	 * A table of flags that control (per series) whether or not shapes are
	 * filled.
	 */
	@SuppressWarnings("unused")
	private BooleanList seriesShapesFilled;

	/** The default value returned by the getShapeFilled() method. */
	@SuppressWarnings("unused")
	private boolean baseShapesFilled;

	/** A flag that controls whether outlines are drawn for shapes. */
	private boolean drawOutlines;

	/**
	 * A flag that controls whether the fill paint is used for filling
	 * shapes.
	 */
	private boolean useFillPaint;

	/**
	 * A flag that controls whether the outline paint is used for drawing shape
	 * outlines.
	 */
	@SuppressWarnings("unused")
	private boolean useOutlinePaint;

	/**
	 * A flag that controls whether or not each series is drawn as a single
	 * path.
	 */
	private boolean drawSeriesLineAsPath;

	/**
	 * Creates a new renderer with both lines and shapes visible.
	 */
	public TriangularXYLineAndShapeRenderer() {
		this(true, true);
	}

	/**
	 * Creates a new renderer.
	 *
	 * @param lines  lines visible?
	 * @param shapes  shapes visible?
	 */
	public TriangularXYLineAndShapeRenderer(boolean lines, boolean shapes) {
		this.linesVisible = null;
		this.seriesLinesVisible = new BooleanList();
		this.baseLinesVisible = lines;
		this.legendLine = new Line2D.Double(-7.0, 0.0, 7.0, 0.0);

		this.shapesVisible = null;
		this.seriesShapesVisible = new BooleanList();
		this.baseShapesVisible = shapes;

		this.shapesFilled = null;
		this.useFillPaint = false;     // use item paint for fills by default
		this.seriesShapesFilled = new BooleanList();
		this.baseShapesFilled = true;

		this.drawOutlines = true;
		this.useOutlinePaint = false;  // use item paint for outlines by
		// default, not outline paint

		this.drawSeriesLineAsPath = false;
	}


	boolean tieLine = false;


	public void setTieLine(boolean on){
		this.tieLine = on;
	}


	/**
	 * Draws the visual representation of a single data item.
	 *
	 * @param g2  the graphics device.
	 * @param state  the renderer state.
	 * @param dataArea  the area within which the data is being drawn.
	 * @param info  collects information about the drawing.
	 * @param plot  the plot (can be used to obtain standard color
	 *              information etc).
	 * @param domainAxis  the domain axis.
	 * @param rangeAxis  the range axis.
	 * @param dataset  the dataset.
	 * @param series  the series index (zero-based).
	 * @param item  the item index (zero-based).
	 * @param crosshairState  crosshair information for the plot
	 *                        (<code>null</code> permitted).
	 * @param pass  the pass index.
	 */
	@Override
	public void drawItem(Graphics2D g2, XYItemRendererState state,
			Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot,
			ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset,
			int series, int item, CrosshairState crosshairState, int pass) {

		// do nothing if item is not visible
		if (!getItemVisible(series, item)) {
			return;
		}

		// first pass draws the background (lines, for instance)
		if (isLinePass(pass)) {
			if (getItemLineVisible(series, item)) {
				if (this.drawSeriesLineAsPath) {
					drawPrimaryLineAsPath(state, g2, plot, dataset, pass,
							series, item, domainAxis, rangeAxis, dataArea);
				}
				else {
					drawPrimaryLine(state, g2, plot, dataset, pass, series,
							item, domainAxis, rangeAxis, dataArea);
				}
			}
		}
		// second pass adds shapes where the items are ..
		else if (isItemPass(pass)) {

			// setup for collecting optional entity info...
			EntityCollection entities = null;
			if (info != null && info.getOwner() != null) {
				entities = info.getOwner().getEntityCollection();
			}

			drawSecondaryPass(g2, plot, dataset, pass, series, item,
					domainAxis, dataArea, rangeAxis, crosshairState, entities);
		}
	}

	/**
	 * Returns <code>true</code> if the specified pass is the one for drawing
	 * lines.
	 *
	 * @param pass  the pass.
	 *
	 * @return A boolean.
	 */
	protected boolean isLinePass(int pass) {
		return pass == 0;
	}

	/**
	 * Returns <code>true</code> if the specified pass is the one for drawing
	 * items.
	 *
	 * @param pass  the pass.
	 *
	 * @return A boolean.
	 */
	protected boolean isItemPass(int pass) {
		return pass == 1;
	}

	/**
	 * Draws the item (first pass). This method draws the lines
	 * connecting the items.
	 *
	 * @param g2  the graphics device.
	 * @param state  the renderer state.
	 * @param dataArea  the area within which the data is being drawn.
	 * @param plot  the plot (can be used to obtain standard color
	 *              information etc).
	 * @param domainAxis  the domain axis.
	 * @param rangeAxis  the range axis.
	 * @param dataset  the dataset.
	 * @param pass  the pass.
	 * @param series  the series index (zero-based).
	 * @param item  the item index (zero-based).
	 */
	protected void drawPrimaryLine(XYItemRendererState state,
			Graphics2D g2,
			XYPlot plot,
			XYDataset dataset,
			int pass,
			int series,
			int item,
			ValueAxis domainAxis,
			ValueAxis rangeAxis,
			Rectangle2D dataArea) {
		if (item == 0) {
			return;
		}

		// get the data point...
		double x1 = dataset.getXValue(series, item);
		double y1 = dataset.getYValue(series, item);
		if (Double.isNaN(y1) || Double.isNaN(x1)) {
			return;
		}

		double x0 = dataset.getXValue(series, item - 1);
		double y0 = dataset.getYValue(series, item - 1);
		if (Double.isNaN(y0) || Double.isNaN(x0)) {
			return;
		}

		double topY0 = dataArea.getMaxY() - dataArea.getWidth() / 2.0 * Math.tan(Math.PI / 180.0 * 60.0);
		double endY0 = dataArea.getMaxY();

		double z0 = 1.0 - x0 - y0;
		double offset0 = 0.5 * z0 * dataArea.getWidth();
		double transX0 =  dataArea.getX() + x0*dataArea.getWidth()  + offset0;
		double transY0 = topY0 + (1-z0) * (endY0-topY0);

		double topY1 = dataArea.getMaxY() - dataArea.getWidth() / 2.0 * Math.tan(Math.PI / 180.0 * 60.0);
		double endY1 = dataArea.getMaxY();

		double z1 = 1.0 - x1 - y1;
		double offset1 = 0.5 * z1 * dataArea.getWidth();
		double transX1 =  dataArea.getX() + x1*dataArea.getWidth()  + offset1;
		double transY1 = topY1 + (1-z1) * (endY1-topY1);


		// only draw if we have good values
		if (Double.isNaN(transX0) || Double.isNaN(transY0)
				|| Double.isNaN(transX1) || Double.isNaN(transY1)) {
			return;
		}

		PlotOrientation orientation = plot.getOrientation();
		boolean visible;
		if (orientation == PlotOrientation.HORIZONTAL) {
			state.workingLine.setLine(transY0, transX0, transY1, transX1);
		}
		else if (orientation == PlotOrientation.VERTICAL) {
			state.workingLine.setLine(transX0, transY0, transX1, transY1);
		}
		visible = LineUtilities.clipLine(state.workingLine, dataArea);
		if (visible) {
			drawFirstPassShape(g2, pass, series, item, state.workingLine);
		}
	}

	/**
	 * Draws the first pass shape.
	 *
	 * @param g2  the graphics device.
	 * @param pass  the pass.
	 * @param series  the series index.
	 * @param item  the item index.
	 * @param shape  the shape.
	 */
	protected void drawFirstPassShape(Graphics2D g2, int pass, int series,
			int item, Shape shape) {
		g2.setStroke(getItemStroke(series, item));
		g2.setPaint(getItemPaint(series, item));
		g2.draw(shape);
	}


	/**
	 * Draws the item (first pass). This method draws the lines
	 * connecting the items. Instead of drawing separate lines,
	 * a GeneralPath is constructed and drawn at the end of
	 * the series painting.
	 *
	 * @param g2  the graphics device.
	 * @param state  the renderer state.
	 * @param plot  the plot (can be used to obtain standard color information
	 *              etc).
	 * @param dataset  the dataset.
	 * @param pass  the pass.
	 * @param series  the series index (zero-based).
	 * @param item  the item index (zero-based).
	 * @param domainAxis  the domain axis.
	 * @param rangeAxis  the range axis.
	 * @param dataArea  the area within which the data is being drawn.
	 */
	protected void drawPrimaryLineAsPath(XYItemRendererState state,
			Graphics2D g2, XYPlot plot, XYDataset dataset, int pass,
			int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis,
			Rectangle2D dataArea) {

		// get the data point...
		double x1 = dataset.getXValue(series, item);
		double y1 = dataset.getYValue(series, item);
		double topY1 = dataArea.getMaxY() - dataArea.getWidth() / 2.0 * Math.tan(Math.PI / 180.0 * 60.0);
		double endY1 = dataArea.getMaxY();

		double z1 = 1.0 - x1 - y1;
		double offset1 = 0.5 * z1 * dataArea.getWidth();
		double transX1 =  dataArea.getX() + x1*dataArea.getWidth()  + offset1;
		double transY1 = topY1 + (1-z1) * (endY1-topY1);

		State s = (State) state;
		// update path to reflect latest point
		if (!Double.isNaN(transX1) && !Double.isNaN(transY1)) {
			float x = (float) transX1;
			float y = (float) transY1;
			PlotOrientation orientation = plot.getOrientation();
			if (orientation == PlotOrientation.HORIZONTAL) {
				x = (float) transY1;
				y = (float) transX1;
			}
			if (s.isLastPointGood()) {
				s.seriesPath.lineTo(x, y);
			}
			else {
				s.seriesPath.moveTo(x, y);
			}
			s.setLastPointGood(true);
		}
		else {
			s.setLastPointGood(false);
		}
		// if this is the last item, draw the path ...
		if (item == s.getLastItemIndex()) {
			// draw path
			drawFirstPassShape(g2, pass, series, item, s.seriesPath);
		}
	}

	/**
	 * Draws the item shapes and adds chart entities (second pass). This method
	 * draws the shapes which mark the item positions. If <code>entities</code>
	 * is not <code>null</code> it will be populated with entity information
	 * for points that fall within the data area.
	 *
	 * @param g2  the graphics device.
	 * @param plot  the plot (can be used to obtain standard color
	 *              information etc).
	 * @param domainAxis  the domain axis.
	 * @param dataArea  the area within which the data is being drawn.
	 * @param rangeAxis  the range axis.
	 * @param dataset  the dataset.
	 * @param pass  the pass.
	 * @param series  the series index (zero-based).
	 * @param item  the item index (zero-based).
	 * @param crosshairState  the crosshair state.
	 * @param entities the entity collection.
	 */
	protected void drawSecondaryPass(Graphics2D g2, XYPlot plot, 
			XYDataset dataset, int pass, int series, int item,
			ValueAxis domainAxis, Rectangle2D dataArea, ValueAxis rangeAxis,
			CrosshairState crosshairState, EntityCollection entities) {

		Shape entityArea = null;

		// get the data point...
		double x1 = dataset.getXValue(series, item);
		double y1 = dataset.getYValue(series, item);
		if (Double.isNaN(y1) || Double.isNaN(x1)) {
			return;
		}

		PlotOrientation orientation = plot.getOrientation();
		double topY1 = dataArea.getMaxY() - dataArea.getWidth() / 2.0 * Math.tan(Math.PI / 180.0 * 60.0);
		double endY1 = dataArea.getMaxY();

		double z1 = 1.0 - x1 - y1;
		double offset1 = 0.5 * z1 * dataArea.getWidth();
		double transX1 =  dataArea.getX() + x1*dataArea.getWidth()  + offset1;
		double transY1 = topY1 + (1-z1) * (endY1-topY1);



		if (getItemShapeVisible(series, item)) {
			Shape shape = getItemShape(series, item);
			if (orientation == PlotOrientation.HORIZONTAL) {
				shape = ShapeUtilities.createTranslatedShape(shape, transY1,
						transX1);
			}
			else if (orientation == PlotOrientation.VERTICAL) {
				shape = ShapeUtilities.createTranslatedShape(shape, transX1,
						transY1);
			}
			entityArea = shape;
			if (shape.intersects(dataArea)) {
				if (getItemShapeFilled(series, item)) {
					if (this.useFillPaint) {
						g2.setPaint(getItemFillPaint(series, item));
					}
					else {
						g2.setPaint(getItemPaint(series, item));
					}
					g2.fill(shape);
				}
				if (this.drawOutlines) {
					if (getUseOutlinePaint()) {
						g2.setPaint(getItemOutlinePaint(series, item));
					}
					else {
						g2.setPaint(getItemPaint(series, item));
					}
					g2.setStroke(getItemOutlineStroke(series, item));
					g2.draw(shape);
				}
			}
		}

		double xx = transX1;
		double yy = transY1;
		if (orientation == PlotOrientation.HORIZONTAL) {
			xx = transY1;
			yy = transX1;
		}

		// draw the item label if there is one...
		if (isItemLabelVisible(series, item)) {
			drawItemLabel(g2, orientation, dataset, series, item, xx, yy,
					(y1 < 0.0));
		}

		// TODO fix this part
				int domainAxisIndex = plot.getDomainAxisIndex(domainAxis);
				int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis);
				updateCrosshairValues(crosshairState, x1, y1, domainAxisIndex,
						rangeAxisIndex, transX1, transY1, orientation);

		// add an entity for the item, but only if it falls within the data
		// area...
		if (entities != null && isPointInRect(dataArea, xx, yy)) {
			addEntity(entities, entityArea, dataset, series, item, xx, yy);
		}
	}


	/**
	 * Provides serialization support.
	 *
	 * @param stream  the input stream.
	 *
	 * @throws IOException  if there is an I/O error.
	 * @throws ClassNotFoundException  if there is a classpath problem.
	 */
	private void readObject(ObjectInputStream stream)
			throws IOException, ClassNotFoundException {
		stream.defaultReadObject();
		this.legendLine = SerialUtilities.readShape(stream);
	}

	/**
	 * Provides serialization support.
	 *
	 * @param stream  the output stream.
	 *
	 * @throws IOException  if there is an I/O error.
	 */
	private void writeObject(ObjectOutputStream stream) throws IOException {
		stream.defaultWriteObject();
		SerialUtilities.writeShape(this.legendLine, stream);
	}

}
